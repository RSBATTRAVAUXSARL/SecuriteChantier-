<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Safety Tap ‚Äî Pixel chantier</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b1020; overflow:hidden; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas {
      width:100vw; height:100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      touch-action: none; /* IMPORTANT iOS/Android */
      display:block;
    }
    .overlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }
    .card {
      pointer-events:auto;
      width:min(520px, 92vw);
      background:rgba(10,14,28,.92);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:16px 16px 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
    }
    .title { font-size:20px; font-weight:800; letter-spacing:.2px; margin:0 0 8px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    .btn {
      cursor:pointer; user-select:none;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
      color:#eaf0ff;
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      flex:1;
      text-align:center;
    }
    .btn.primary { background:rgba(255,210,90,.18); border-color:rgba(255,210,90,.35); }
    .btn.danger { background:rgba(255,90,90,.14); border-color:rgba(255,90,90,.35); }
    .muted { color:rgba(234,240,255,.72); font-size:13px; line-height:1.35; margin-top:10px; }
    .pill {
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.05);
      font-size:12px; font-weight:700;
    }
    .spacer { height:8px; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="overlay" id="menu">
  <div class="card">
    <div class="title">Safety Tap ‚Äî Chantier (Pixel)</div>
    <div class="row">
      <div class="pill">üéØ Tape uniquement les ouvriers <b>SANS casque</b></div>
      <div class="pill">‚è±Ô∏è 60s ‚Ä¢ Combo ‚Ä¢ Bonus</div>
    </div>
    <div class="spacer"></div>
    <div class="row">
      <div class="btn primary" id="playNormal">Jouer (Normal)</div>
      <div class="btn" id="playHard">Jouer (Hard)</div>
    </div>
    <div class="spacer"></div>
    <div class="row">
      <div class="btn" id="how">R√®gles</div>
      <div class="btn danger" id="mute">Son: ON</div>
    </div>
    <div class="muted" id="rules" style="display:none">
      <b>R√®gles:</b><br>
      ‚úÖ Sans casque = +points +combo<br>
      ‚ùå Casque = malus +combo reset<br>
      ‚ö†Ô∏è Si un sans-casque sort de l‚Äô√©cran = malus +combo reset<br>
      ‚≠ê Golden (rare, sans casque) = gros bonus<br>
      üê∂ Chien = pi√®ge (si tap = gros malus)<br>
      üõë Panneau STOP = freeze 2s (bonus)<br><br>
      <b>Hard:</b> certains ont un casque <i>mal attach√©</i> (mentonni√®re rouge) : si tu tapes, c‚Äôest consid√©r√© comme ‚Äúfaux‚Äù.
    </div>
    <div class="muted">iOS/Android: tape direct sur l‚Äô√©cran. Le jeu est optimis√© tactile + ‚Äúpixelated‚Äù.</div>
  </div>
</div>

<script>
(() => {
  // ---------- Helpers ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));
  const now = ()=>performance.now();

  // ---------- Canvas & DPI ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  let W=0,H=0, DPR=1;

  // Internal game resolution (keeps pixel vibe)
  const BASE_W = 360;
  const BASE_H = 640;
  let scale = 1;

  function resize() {
    const vw = Math.floor(window.innerWidth);
    const vh = Math.floor(window.innerHeight);
    DPR = Math.min(3, window.devicePixelRatio || 1);

    // Fit base resolution into viewport (integer-ish scale for crisp pixels)
    const s = Math.min(vw/BASE_W, vh/BASE_H);
    scale = Math.max(1, Math.floor(s * 2) / 2); // allow .5 steps
    W = Math.floor(BASE_W * scale);
    H = Math.floor(BASE_H * scale);

    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';

    // center canvas via body background (canvas already full, but we set fixed size)
    // Use CSS 100vw/100vh; we keep canvas scaled inside.
    // We'll translate to center in draw.
    ctx.setTransform(1,0,0,1,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // ---------- Audio (tiny blips) ----------
  let soundOn = true;
  let audioCtx = null;
  function beep(freq=440, dur=0.05, type='square', gain=0.03){
    if(!soundOn) return;
    try{
      audioCtx ||= new (window.AudioContext || window.webkitAudioContext)();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t0); o.stop(t0 + dur);
    }catch(e){}
  }

  // ---------- UI Menu ----------
  const menu = document.getElementById('menu');
  const rules = document.getElementById('rules');
  document.getElementById('how').onclick = () => {
    rules.style.display = (rules.style.display==='none') ? 'block' : 'none';
  };
  const muteBtn = document.getElementById('mute');
  muteBtn.onclick = () => {
    soundOn = !soundOn;
    muteBtn.textContent = 'Son: ' + (soundOn ? 'ON' : 'OFF');
    muteBtn.classList.toggle('danger', soundOn);
  };

  // ---------- Game State ----------
  const STATE = { MENU:0, RUN:1, OVER:2 };
  let state = STATE.MENU;
  let modeHard = false;

  const game = {
    tStart: 0,
    tLast: 0,
    timer: 60,
    score: 0,
    best: 0,
    combo: 0,
    comboTime: 0,
    freezeUntil: 0,
    spawnAcc: 0,
    spawnRate: 0.95, // entities/sec baseline (will ramp)
    ramp: 0,
    entities: [],
    pops: [],
    bg: { cloudX: 0, cloudY: 40 },
  };

  // Entity types:
  // worker: hasHelmet, golden, badStrap (hard), dir, speed, y, w,h
  // dog: trap
  // stop: bonus freeze
  const laneY = () => {
    // Two lanes for variety
    const top = Math.floor(BASE_H*0.52);
    const bot = Math.floor(BASE_H*0.67);
    return (Math.random()<0.5) ? top : bot;
  };

  function resetGame(){
    game.tStart = now();
    game.tLast = game.tStart;
    game.timer = 60;
    game.score = 0;
    game.combo = 0;
    game.comboTime = 0;
    game.freezeUntil = 0;
    game.spawnAcc = 0;
    game.spawnRate = 0.95;
    game.ramp = 0;
    game.entities.length = 0;
    game.pops.length = 0;
  }

  function start(normal=true){
    modeHard = !normal;
    resetGame();
    state = STATE.RUN;
    menu.style.display = 'none';
    beep(660,0.06,'square',0.03);
  }

  document.getElementById('playNormal').onclick = () => start(true);
  document.getElementById('playHard').onclick = () => start(false);

  // ---------- Pixel Drawing Primitives ----------
  function pxRect(x,y,w,h,color){
    ctx.fillStyle = color;
    ctx.fillRect(x,y,w,h);
  }
  function pxOutline(x,y,w,h,color){
    ctx.strokeStyle = color;
    ctx.strokeRect(x,y,w,h);
  }

  // Draw a worker sprite (pixel-ish) in base coordinates
  function drawWorker(e){
    const x = e.x, y = e.y;
    const s = 1; // base pixel size = 1 (we scale whole canvas later)
    const flip = e.dir < 0;
    // body palette
    const skin = '#d7b08a';
    const dark = '#1c2238';
    const vest = '#ffb74d';
    const vest2 = '#ff8f2a';
    const pants = '#2c5aa0';
    const boot = '#111726';
    const helmet = e.hasHelmet ? '#ffd24b' : null;
    const hair = '#3b2a1d';
    const gold = '#ffe066';

    // Simple 16x20 sprite
    // We'll use a local function with optional flip
    const put = (dx,dy,w,h,col)=>{
      const rx = flip ? (x + (e.w - (dx+w))) : (x+dx);
      pxRect(rx, y+dy, w, h, col);
    };

    // Shadow
    pxRect(x+2, y+e.h-2, e.w-4, 2, 'rgba(0,0,0,.35)');

    // Legs
    put(5, 14, 3, 4, pants);
    put(8, 14, 3, 4, pants);
    // Boots
    put(4, 18, 4, 2, boot);
    put(8, 18, 4, 2, boot);

    // Torso
    put(4, 9, 8, 6, vest);
    put(4, 11, 8, 1, vest2); // stripe

    // Arms (tiny)
    put(2, 10, 2, 3, vest);
    put(12,10, 2, 3, vest);

    // Head
    put(6, 5, 4, 4, skin);

    // Face/hair
    if(!e.hasHelmet){
      put(6, 4, 4, 2, hair);
    } else {
      // Helmet
      put(5, 3, 6, 3, e.golden ? gold : helmet);
      put(5, 6, 6, 1, '#caa12b');
      // Small brim
      put(4, 6, 1, 1, '#caa12b');
    }

    // Hard mode: bad strap indicator (red chin strap)
    if(modeHard && e.hasHelmet && e.badStrap){
      put(6, 8, 4, 1, '#ff4d4d');
    }

    // Golden glow
    if(e.golden){
      pxRect(x-1, y+3, 1, 10, 'rgba(255,224,102,.35)');
      pxRect(x+e.w, y+3, 1, 10, 'rgba(255,224,102,.35)');
    }
  }

  function drawDog(e){
    const x=e.x,y=e.y;
    const flip = e.dir<0;
    const put=(dx,dy,w,h,col)=>{
      const rx = flip ? (x + (e.w - (dx+w))) : (x+dx);
      pxRect(rx,y+dy,w,h,col);
    };
    // shadow
    pxRect(x+2,y+e.h-2,e.w-4,2,'rgba(0,0,0,.35)');
    // body 18x10
    put(4,10,10,5,'#5b3a22');
    put(2,12,4,3,'#5b3a22');
    put(14,12,3,2,'#5b3a22'); // tail
    // legs
    put(5,15,2,3,'#2b1a10');
    put(10,15,2,3,'#2b1a10');
    // head
    put(0,10,5,4,'#6a4226');
    put(1,9,3,2,'#6a4226'); // ear
    put(3,12,2,1,'#111');   // eye
  }

  function drawStop(e){
    const x=e.x,y=e.y;
    // Sign pole
    pxRect(x+8,y+6,2,14,'#9aa3b2');
    // Sign
    pxRect(x+2,y+0,14,10,'#e23b3b');
    pxRect(x+3,y+1,12,8,'#c92f2f');
    // "STOP" pixels
    pxRect(x+4,y+4,10,1,'#fff');
    pxRect(x+4,y+6,10,1,'#fff');
    // shadow
    pxRect(x+2,y+20,14,2,'rgba(0,0,0,.35)');
  }

  // ---------- Spawning ----------
  function spawnEntity(){
    const r = Math.random();

    // Rare bonus/trap spawns
    if(r < 0.08){
      // stop sign bonus
      const dir = Math.random()<0.5 ? 1 : -1;
      const w=18,h=22;
      const x = (dir>0) ? -w : BASE_W + w;
      game.entities.push({ kind:'stop', x, y: laneY()-10, w, h, dir, speed: rand(40,70) });
      return;
    }
    if(r < 0.14){
      // dog trap
      const dir = Math.random()<0.5 ? 1 : -1;
      const w=18,h=20;
      const x = (dir>0) ? -w : BASE_W + w;
      game.entities.push({ kind:'dog', x, y: laneY()+2, w, h, dir, speed: rand(70,110) });
      return;
    }

    // Worker
    const dir = Math.random()<0.5 ? 1 : -1;
    const w=16,h=20;
    const x = (dir>0) ? -w : BASE_W + w;

    // chance no-helmet increases with ramp
    const baseNoHelmet = 0.33 + clamp(game.ramp*0.10, 0, 0.25);
    const hasHelmet = Math.random() > baseNoHelmet;

    // golden: rare, only if no-helmet (target)
    const golden = (!hasHelmet && Math.random()<0.06);

    // hard: some helmet have bad strap (still helmet visually)
    const badStrap = (hasHelmet && Math.random() < 0.18);

    const speed = rand(55, 120) * (1 + game.ramp*0.18);
    game.entities.push({
      kind:'worker', x, y: laneY(), w, h, dir, speed,
      hasHelmet, golden, badStrap,
      tapped:false
    });
  }

  // ---------- Scoring & Pops ----------
  function addPop(x,y,text,color){
    game.pops.push({ x, y, text, color, t:0 });
  }

  function awardHit(e){
    // Correct hit: only no-helmet workers
    let pts = e.golden ? 100 : 10;
    // combo
    game.combo = clamp(game.combo + 1, 0, 99);
    pts += Math.min(60, (game.combo-1) * 2);
    game.score += pts;
    game.comboTime = 0;

    addPop(e.x+6, e.y-10, `+${pts}`, e.golden ? '#ffe066' : '#7CFF9A');
    beep(e.golden ? 880 : 740, e.golden ? 0.09 : 0.06, 'square', e.golden ? 0.04 : 0.03);
  }

  function punishFalse(text, x, y, amount){
    game.score = Math.max(0, game.score - amount);
    game.combo = 0;
    game.comboTime = 0;
    addPop(x, y, text, '#ff6b6b');
    beep(220,0.08,'square',0.035);
  }

  function freezeBonus(x,y){
    game.freezeUntil = Math.max(game.freezeUntil, (now() + 2000));
    addPop(x, y, 'üõë FREEZE', '#7fd1ff');
    beep(520,0.05,'square',0.03);
    beep(420,0.06,'square',0.03);
  }

  // ---------- Input (Pointer events for iOS/Android/Desktop) ----------
  function getPointerPos(ev){
    const rect = canvas.getBoundingClientRect();
    const px = (ev.clientX - rect.left) / rect.width * BASE_W;
    const py = (ev.clientY - rect.top) / rect.height * BASE_H;
    return { x:px, y:py };
  }

  canvas.addEventListener('pointerdown', (ev)=>{
    ev.preventDefault();
    if(state === STATE.MENU) return;
    if(state === STATE.OVER){
      // restart quick
      start(!modeHard);
      return;
    }
    if(state !== STATE.RUN) return;

    // unlock audio on iOS if needed
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume?.();

    const p = getPointerPos(ev);

    // Check entities front-to-back (last spawned tends to be on top)
    for(let i=game.entities.length-1;i>=0;i--){
      const e = game.entities[i];
      const hit = (p.x>=e.x && p.x<=e.x+e.w && p.y>=e.y && p.y<=e.y+e.h);
      if(!hit) continue;

      if(e.kind==='stop'){
        freezeBonus(p.x, p.y);
        game.entities.splice(i,1);
        return;
      }
      if(e.kind==='dog'){
        punishFalse('-50 üê∂', p.x, p.y, 50);
        game.entities.splice(i,1);
        return;
      }
      if(e.kind==='worker'){
        // Hard mode: helmet with bad strap counts as "should not be tapped" (still a false tap)
        const isBadTap = e.hasHelmet || (modeHard && e.hasHelmet && e.badStrap);
        if(isBadTap){
          punishFalse('-20 ‚ùå', p.x, p.y, 20);
        } else {
          awardHit(e);
        }
        game.entities.splice(i,1);
        return;
      }
    }

    // tapped empty: small penalty in hard? (keep it fun: no penalty)
  }, { passive:false });

  // ---------- Update Loop ----------
  function update(dt){
    // timer
    game.timer = Math.max(0, game.timer - dt);
    if(game.timer <= 0){
      state = STATE.OVER;
      game.best = Math.max(game.best, game.score);
      menu.style.display = 'flex';
      // Replace card content quickly (lightweight)
      menu.querySelector('.title').textContent = 'Fin de partie';
      rules.style.display = 'none';
      menu.querySelector('.muted').innerHTML =
        `Score: <b>${game.score}</b> ‚Ä¢ Record: <b>${game.best}</b><br>` +
        `Tape l‚Äô√©cran pour rejouer. (ou bouton Jouer)`;
      beep(180,0.12,'square',0.04);
      return;
    }

    // ramp difficulty
    game.ramp = clamp((60 - game.timer)/60, 0, 1);
    const targetRate = 0.95 + game.ramp*1.35; // up to ~2.3/sec
    game.spawnRate = targetRate;

    // combo decay (if idle too long)
    game.comboTime += dt;
    if(game.combo > 0 && game.comboTime > 2.2){
      game.combo = 0;
    }

    // spawning
    game.spawnAcc += dt * game.spawnRate;
    while(game.spawnAcc >= 1){
      game.spawnAcc -= 1;
      spawnEntity();
    }

    const frozen = now() < game.freezeUntil;

    // move entities
    for(let i=game.entities.length-1;i>=0;i--){
      const e = game.entities[i];
      if(!frozen){
        e.x += e.dir * e.speed * dt;
      }

      // offscreen handling
      const off = (e.dir>0) ? (e.x > BASE_W + e.w) : (e.x < -2*e.w);
      if(off){
        // Miss penalty only for no-helmet worker
        if(e.kind==='worker' && !e.hasHelmet){
          punishFalse('-5 ‚ö†Ô∏è MISS', clamp(e.x,0,BASE_W), clamp(e.y,0,BASE_H), 5);
        }
        game.entities.splice(i,1);
      }
    }

    // pops
    for(let i=game.pops.length-1;i>=0;i--){
      const p = game.pops[i];
      p.t += dt;
      p.y -= 18*dt;
      if(p.t > 0.9) game.pops.splice(i,1);
    }

    // background clouds
    if(!frozen){
      game.bg.cloudX = (game.bg.cloudX + 10*dt) % (BASE_W+80);
    }
  }

  // ---------- Draw ----------
  function draw(){
    // Clear & center
    const vw = canvas.getBoundingClientRect().width;
    const vh = canvas.getBoundingClientRect().height;
    // We draw in BASE coords, then scale to fit canvas CSS size.
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);

    const ox = Math.floor((vw - W)/2);
    const oy = Math.floor((vh - H)/2);

    // Map base space to actual displayed canvas area
    const sx = W/BASE_W;
    const sy = H/BASE_H;

    ctx.save();
    ctx.translate(ox, oy);
    ctx.scale(sx, sy);

    // Sky
    pxRect(0,0,BASE_W,BASE_H,'#86bdf2');
    // distant skyline
    for(let i=0;i<10;i++){
      const bx = 10 + i*34;
      const bh = 60 + (i%3)*28;
      pxRect(bx, 120-bh, 18, bh, 'rgba(18,28,60,.35)');
      pxRect(bx+2, 120-bh+6, 5, 8, 'rgba(255,255,255,.08)');
    }
    // clouds
    const cx = BASE_W - game.bg.cloudX;
    pxRect(cx-20,40,20,8,'rgba(255,255,255,.85)');
    pxRect(cx-10,36,22,10,'rgba(255,255,255,.85)');
    pxRect(cx+8,40,18,8,'rgba(255,255,255,.85)');

    // Crane (simple)
    pxRect(260, 90, 6, 140, '#f0a93a');
    pxRect(130, 90, 170, 6, '#f0a93a');
    pxRect(210, 96, 2, 40, '#3a2a15');
    pxRect(206, 136, 10, 4, '#3a2a15');

    // Ground
    pxRect(0, BASE_H*0.45|0, BASE_W, BASE_H, '#c9a46b');
    // Road/lanes
    const lane1 = BASE_H*0.52|0, lane2 = BASE_H*0.67|0;
    pxRect(0,lane1+18,BASE_W,22,'rgba(0,0,0,.08)');
    pxRect(0,lane2+18,BASE_W,22,'rgba(0,0,0,.08)');

    // Foreground props
    // cones
    for(let i=0;i<6;i++){
      const x= 20 + i*55;
      pxRect(x, BASE_H-46, 10, 18, '#ff7a2f');
      pxRect(x+2, BASE_H-38, 6, 2, '#fff');
      pxRect(x+2, BASE_H-30, 6, 2, '#fff');
      pxRect(x-2, BASE_H-28, 14, 2, 'rgba(0,0,0,.25)');
    }
    // barrier
    pxRect(6, BASE_H-86, 80, 8, '#ffb74d');
    pxRect(6, BASE_H-78, 80, 6, '#ff8f2a');
    pxRect(10, BASE_H-72, 4, 18, '#9aa3b2');
    pxRect(72, BASE_H-72, 4, 18, '#9aa3b2');

    // HUD bar
    pxRect(0,0,BASE_W,34,'rgba(8,12,30,.72)');
    pxRect(0,34,BASE_W,1,'rgba(255,255,255,.12)');

    // Score / Combo / Timer
    ctx.fillStyle = '#eaf0ff';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText(`Score ${game.score}`, 10, 22);

    ctx.fillStyle = game.combo>=2 ? '#7CFF9A' : 'rgba(234,240,255,.75)';
    ctx.fillText(`Combo x${Math.max(1,game.combo)}`, 130, 22);

    // timer bar
    const tW = 90;
    const tX = BASE_W - (tW+10);
    const tP = game.timer/60;
    pxRect(tX, 12, tW, 10, 'rgba(255,255,255,.12)');
    pxRect(tX, 12, Math.max(0, Math.floor(tW*tP)), 10, tP>0.25 ? 'rgba(124,255,154,.85)' : 'rgba(255,107,107,.85)');
    ctx.fillStyle = '#eaf0ff';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`${Math.ceil(game.timer)}s`, tX + tW + 6, 21);

    // Freeze indicator
    if(now() < game.freezeUntil){
      pxRect(0,34,BASE_W,14,'rgba(127,209,255,.18)');
      ctx.fillStyle = '#7fd1ff';
      ctx.font = 'bold 11px system-ui';
      ctx.fillText('FREEZE üõë', 10, 45);
    }

    // Entities
    // slight depth sort by y
    game.entities.sort((a,b)=> (a.y+a.h) - (b.y+b.h));
    for(const e of game.entities){
      if(e.kind==='worker') drawWorker(e);
      else if(e.kind==='dog') drawDog(e);
      else if(e.kind==='stop') drawStop(e);
    }

    // Pops
    for(const p of game.pops){
      const a = 1 - clamp(p.t/0.9, 0, 1);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.font = 'bold 12px system-ui';
      ctx.fillText(p.text, p.x, p.y);
      ctx.globalAlpha = 1;
    }

    // bottom hint
    ctx.fillStyle = 'rgba(8,12,30,.55)';
    pxRect(0, BASE_H-26, BASE_W, 26, 'rgba(8,12,30,.55)');
    ctx.fillStyle = 'rgba(234,240,255,.82)';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('üéØ Tape uniquement SANS casque ‚Ä¢ üê∂ pi√®ge ‚Ä¢ üõë bonus', 10, BASE_H-9);

    ctx.restore();
  }

  // ---------- Main loop ----------
  function loop(t){
    if(state === STATE.RUN){
      const dt = Math.min(0.033, (t - game.tLast)/1000);
      game.tLast = t;
      update(dt);
    }
    draw();
    requestAnimationFrame(loop);
  }

  // Reset menu title if coming from game over
  function resetMenuTitle(){
    menu.querySelector('.title').textContent = 'Safety Tap ‚Äî Chantier (Pixel)';
    menu.querySelector('.muted').textContent =
      "iOS/Android: tape direct sur l‚Äô√©cran. Le jeu est optimis√© tactile + ‚Äúpixelated‚Äù.";
  }

  // If user hits play after game over, restore menu title (done in start)
  const origStart = start;
  start = function(normal=true){
    resetMenuTitle();
    origStart(normal);
  };

  // Start animation loop
  requestAnimationFrame((t)=>{
    game.tLast = t;
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>
